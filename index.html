<!DOCTYPE html>
<html>
<!--
made by yudai takegawa
(c) 2017 all rights reserved

you can:
 - distribute
 - modify
you cannot:
 - commercial use
-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Workaholic</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>
        body{
            color:#444;
        }
        .hoverer:hover {
            background-color: #eee;
            color: #000;
            cursor: pointer;
        }
        .delete{
            width: .8em;
        }
        .delete:hover{
            cursor: pointer;
        }
        #showTerm{
            top: 10px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 18px 20px;
            display: inline-block;
            margin-top: 1em;
        }
        #termBack{
            text-align: center;
            position: absolute;
            top:0;
            left: 0;
            width: 100%;
            height: auto !important;
            min-height: 100%;
            display: none;
            z-index: 10;
            background-color: rgba(255,255,255,.5);
            padding-bottom: 15em
        }
        .block {
            padding: 10px;
        }
        #shift_table div{
            margin: 3em 0;
            border: 1px solid #eeeeee;
            border-left: 5px solid #1b809e;
            border-radius: 2px;
            padding: 20px
        }
        #shift_table div h4{
            color :#1b809e;
            font-weight: bold;
        }
        #shift_table div p{
            font-size: 2em
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="termBack">
            <div id="showTerm"></div>
        </div>
        <h2>Workaholic v1.0</h2>
        <p>textareaにシフト表をコピペしてsubmit。submitしたときに、同時にデータをブラウザに保存します。</p>
        <textarea id="shift_textarea" rows="7" class="form-control" placeholder="シフト表を全選択してコピー&ペースト..."></textarea><br>
        <div>
            <input class="btn btn-default" type="submit" value="Submit" id="shift_submit">
        </div>
        <!--insert table here...-->
        <div id="shift_table" style="margin: 3em 0;"></div>
        <div class="checkbox" style="margin-bottom: 10em;">
            <label>
                <input type="checkbox" value="" id="delete_checkbox">
                削除時に警告を表示しない
            </label>
        </div>
        <div class="json">
            <h4>バックアップ用</h4>
            <p>下のtextareaには上のデータがjson形式で表示されます。これをどこかのファイルで保存・共有しておくと、ブラウザが変わったりデバイスが変わってもデータを引き継ぐことができます。</p>
            <textarea id="json_textarea" rows="7" class="form-control" placeholder="" onclick="this.focus();this.select()" readonly="readonly"></textarea>

            <div class="checkbox">
                <label>
                    <input type="checkbox" value="" id="json_checkbox">
                    JSONを整理して表示
                </label>
            </div>
            <br>
            <textarea id="json_input_textarea" rows="3" class="form-control" placeholder="データが消えたとき用、バックアップのjsonから読み込み..."></textarea><br>
            <div style="margin-bottom: 6em">
                <input class="btn btn-default" type="submit" value="Submit" id="json_submit">
            </div>
        </div>
        <p>powered by <a href="http://getbootstrap.com/">bootstrap</a></p>
    </div> <!-- /container -->

</body>
<script type="text/javascript">

/*
 * 使用するlocalStorage
 *  - data: theWorkingTreeをstring化したもの
 *  - json_checkbox: チェックボックスがcheckedである.
 *  - delete_checkbox: 同上
 */

theYggdrasil = {}; // 全部のデータを格納するobj
/*
 * theYggdrasil(全部のデータを格納するobj)の構造は
 * 
 * {
 *   - "2017.8.0" : 8月上半期の勤務obj
 *   - "2017.8.1" : 8月下半期の勤務obj
 *   - "2017.9.0" : 9月上半期の勤務obj
 *   - ...
 * }
 */

showingTerm = false;

today = new Date();

/*
 * チェックボックスの初期化とイベントハンドラ登録。
 */
function initCheckboxAttr() {
    var checkboxIds = ["json_checkbox", "delete_checkbox"];
    for (var boxId of checkboxIds){
        var node = $("#" + boxId);
        var item = localStorage.getItem(boxId);
        if (item === "1"){
            node.checked = true;
        } else {
            node.checked = false;
        }
        // register onchange event handler
        node.onchange = function(e){
            var data = e.srcElement.checked ? "1" : "0";
            localStorage.setItem(e.srcElement.id, data);
        }
    }
}

/*
 * bodyが読み込まれたときに発火する関数。
 */
function bodyLoadEvent() {
    initCheckboxAttr();

    $('#termBack').onclick = function(e){
        if (showingTerm){
            hideTerm();
        }
    };

    $('#showTerm').onclick = function(e){
        e.stopPropagation();
    };

    // shift_submitエレメントにonclick属性を追加。(イベントハンドラを登録)
    $('#shift_submit').onclick = function(){
        extractData();
    };

    $('#json_submit').onclick = function(){
        theYggdrasil = JSON.parse($('#json_input_textarea').value);
        saveData();
    };

    var local_data = localStorage.getItem("data");
    if (local_data != null) {
        if ($('#json_checkbox').checked){
            $('#json_textarea').value = JSON.stringify(JSON.parse(local_data), null, "    ");
        } else {
            $('#json_textarea').value = local_data;
        }
        theYggdrasil = JSON.parse(local_data);
        buildTableContent();
    }
}

function pushWorktime(shifts, sh, sm, fh, fm){
    var start = {"hour": sh, "min": sm};
    var finish = {"hour": fh, "min": fm};
    var _shifts = [];
    var merged = false;
    for (var shift of shifts){
        if (timeEquals(shift["finish"], start)){
             _shifts.push({"start": shift["start"], "finish": finish})
            merged = true;
        } else if (timeEquals(shift["start"], finish)){
            _shifts.push({"start": start, "finish": shift["finish"]})
            merged = true;
        } else {
            _shifts.push(shift);
        }
    }
    if (!merged){
        _shifts.push({"start": start, "finish": finish})
    }
    return _shifts;
}

function timeEquals(time1, time2){
    return time1["hour"] === time2["hour"] && time1["min"] === time2["min"];
}

/*
 * テキストエリアの内容を解釈してJSON化・table化する。
 */
function extractData(){
    ////////この関数のみの変数(var宣言をつける。本当は変数名がかぶらないならいらない。)で、for-loopの外に置いときたい組////////

    var rowValue = $('#shift_textarea').value;
    var lines = rowValue.split('\n');

    var theDay = "";
    var theWorktime = [] // 勤務時間を格納するArray(数がわからず複数個ありうるのでArray)
    var theWorkingTree = {"modified": makeDateString(today, '{0}/{1}/{2}')}; // 半期のデータ記録を格納するObject

    var isFirstHalf = null;
    var theMonth = null;
    var theYear = null;

    ///////////lineごとの処理///////////
    for (var line of lines) {
        var dayMatch = line.match(/\d+\/\d+(?=\([月火水木金土日]\))/g); 
        // Array<String> matches
        // ["8/14"] or null

        if (dayMatch != null && dayMatch.length == 1){
            // この行が8/14(金)[確定]とか書いてある行

            if (theWorktime.length > 0){
                // すでに今までに11:30-22:15とかがあった
                theWorkingTree[theDay] = theWorktime;
                // ツリーに保存 (まだtheDayは前のループ時のtheDay)
                theWorktime = [];
                // 一時データは消去
            }
            theDay = addYearToDay(dayMatch[0]); // "2017/8/14"
            // theDayを更新(次への布石)

            if (isFirstHalf == null){
                var _d = new Date(theDay);
                isFirstHalf = _d.getDate() <= 15;
                theMonth = _d.getMonth() + 1;
                theYear = _d.getFullYear();
            }
        }

        timeMatch = line.match(/(\d+):(\d+)-(\d+):(\d+)/);
        // Array<String> matches
        // ["11:30-12:30", "11", "30", "12", "30"]

        if (timeMatch != null){
            //この行が11:30-20:15とか書いてある行
            theWorktime = pushWorktime(theWorktime, parseInt(timeMatch[1]), parseInt(timeMatch[2]), parseInt(timeMatch[3]), parseInt(timeMatch[4]));
        }
    }
    ///////////end: lineごとの処理///////////
    // ループ後の未完の処理
    if (theWorktime.length > 0){
        theWorkingTree[theDay] = theWorktime;
        theWorktime = [];
    }
    /////////////////line処理完了//////////////////

    if (theYear == null){
        // inputされたデータががおかしかった
        return;
    }

    var _postfix = isFirstHalf ? "0" : "1"; // 前半なら0, 後半なら1
    var _title = theYear + "." +theMonth + "." + _postfix;  //2017.8.0 = 2017年8月前半
    theYggdrasil[_title] = theWorkingTree;

    saveData();

    // textareaの内容をリセット
    $('#shift_textarea').value = '';
}

function saveData() {
    // JSONを整理して表示
    if ($('#json_checkbox').checked){
        $('#json_textarea').value = JSON.stringify(theYggdrasil, null, "    ");
    } else {
        $('#json_textarea').value = JSON.stringify(theYggdrasil);
    }
    buildTableContent();
    localStorage.setItem("data", JSON.stringify(theYggdrasil));
}

function buildTableContent() {
    var theNearestDate = null; // 次の勤務dayのdateobj
    var theNearestWorkTime = []; //次の勤務デイの勤務時間Array

    var keys = Object.keys(theYggdrasil);
    // 並び替え (2017.8.0と2016.9.1など...)
    keys.sort(function(a,b){
        var _as = a.split("."); 
        var _bs = b.split("."); 
        if (parseInt(_as[0]) > parseInt(_bs[0])) return 1; 
        if (parseInt(_as[0]) < parseInt(_bs[0])) return -1; 
        if (parseInt(_as[1]) > parseInt(_bs[1])) return 1;
        if (parseInt(_as[1]) < parseInt(_bs[1])) return -1;
        if (parseInt(_as[2]) > parseInt(_bs[2])) return 1;
        if (parseInt(_as[2]) < parseInt(_bs[2])) return -1;
        return 0;
    });
    ////end: 並び替え////

    var tableHtml = '<table class="table table-striped"><tr><th>#</th><th>期間</th><th>実働時間</th><th>作成日時</th></tr>';

    // 半月毎の処理
    // keysはtheYggdrasilのkey配列を並び替えたもの
    for (var keyTerm of keys) {
        if (!theYggdrasil.hasOwnProperty(keyTerm)) {
            continue;
        }

        var _WorkingTree = theYggdrasil[keyTerm];
        var wholeBondedMin = 0;
        var wholeRestMin = 0;
        var modifiedDay = "";

        /*
         * _WorkingTree(半期の勤務obj)の構造は
         * 
         * {
         *   - "modified" : "2017/7/30"
         *   - "2017/8/1" : [勤務時間Obj1, 勤務時間Obj2...]
         *   - "2017/8/3" : [勤務時間Obj1, 勤務時間Obj2...]
         *   ...
         * }
         */
        for (var keyDay in _WorkingTree){
            if (!_WorkingTree.hasOwnProperty(keyDay)){
                continue;
            }

            // keyDayは"2017/8/1"系か"modified" (modifiedは一回だけ)
            if (keyDay === "modified"){
                modifiedDay = _WorkingTree[keyDay]; // "2017/7/30"とかが格納される
            } else {
                var shifts = _WorkingTree[keyDay]; // Array<Object> [勤務時間Obj1, 勤務時間Obj2...]

                var dateObj = new Date(keyDay); // Date("2017/8/1")
                var _dtime = dateObj.getTime() - today.getTime(); // 今(ただしhtml読み込み時点の時間)との時間差ms
                if (theNearestDate == null || (_dtime > 0 && _dtime < Math.abs(theNearestDate.getTime() - today.getTime()))){
                    // 今より勤務日程があとで、より現時点との時間的距離が近い
                    theNearestDate = dateObj;
                    theNearestWorkTime = shifts;
                }

                for (var shift of shifts){
                    var bonded = getBondedMinute(shift);
                    wholeBondedMin += bonded;
                    wholeRestMin += getRestMin(bonded);
                }
            }
        }
        tableHtml += makeTrHtml(keyTerm, wholeBondedMin - wholeRestMin, modifiedDay);
    }

    tableHtml += '</table>'
    if (theNearestDate != null) {
        tableHtml = '<div><h4>次の出勤日:</h4><p>{0} {1}</p></div>'.format(makeDateString(theNearestDate, '{1}/{2} ({3})'), makeWorktimeString(theNearestWorkTime)) + tableHtml;
    }
    $("#shift_table").innerHTML = tableHtml;
}

function makeWorktimeString(shifts) {
    var r = '';
    var c = 0;
    for (var shift of shifts){
        if (c > 0) r+= ', '
        var _st = shift["start"];
        var _fn = shift["finish"];
        var _sth = _st["hour"];
        var _stm = _st["min"];
        var _fnh = _fn["hour"];
        var _fnm = _fn["min"];
        if (_stm  < 10) _stm = '0' + _stm;
        if (_fnm < 10) _fnm = '0' + _fnm;
        r += '{0}:{1}-{2}:{3}'.format(_sth,_stm,_fnh,_fnm);
        c++;
    }
    return r;
}

/*
 * いろんな形式のdateから好きな形の日付Stringに変換する関数
 */
function makeDateString(input, formatting){
    var days = ["日","月","火","水","木","金","土"]
    var dateObj;
    if (typeof input === 'number'){
        dateObj = new Date(input);
    } else if (input instanceof Date){
        dateObj = input;
    } else if (typeof input === 'string'){
        dateObj = new Date(input);
    }
    var year = dateObj.getFullYear();
    var month = dateObj.getMonth() + 1;
    var date = dateObj.getDate();
    var day = days[dateObj.getDay()];
    return formatting.format(year, month, date, day);
}

/*
 * tableのtrをつくる関数
 */
function makeTrHtml(keyTerm, actualTime, modifiedDay) {
    var _t  = '<tr>'
    _t += '<td><img src="src/delete.svg" title="このデータを削除" class="delete" onclick="deleteTerm(\'{0}\')"></td>'.format(keyTerm);
    _t += '<td title="詳しいデータを見る" class="hoverer" onclick="showTerm(\'{0}\')">{1}</td>'.format(keyTerm, parseKeyTerm(keyTerm));
    _t += '<td>{0}</td>'.format(actualTime/60);
    _t += '<td>{0}</td>'.format(modifiedDay);
    _t += '</tr>';
    return _t;
}

function parseKeyTerm(keyTerm) {
    var _ks = keyTerm.split(".");
    var _post = _ks[2] == "0" ? "前半" : "後半";
    return '{0}月{1}'.format(_ks[1], _post);
}

function deleteTerm(keyTerm){
    if ($('#delete_checkbox').checked || window.confirm("本当に"+parseKeyTerm(keyTerm)+"のデータを削除しますか?")){
        delete theYggdrasil[keyTerm];
        saveData();
    }
}

/*
 * tableのタイトルの部分("8月前半"など)をクリックしたときに発火する関数
 * theYggdrasilから指定の半月分のデータを抜き出し表示。
 * buildTableContent()でも同じような処理があるが、ループ内の処理に若干の差異があるため統合はしない。
 */
function showTerm(keyTerm) {
    var _WorkingTree = theYggdrasil[keyTerm];
    var actualTime = 0;
    var modifiedDay = "";
    var html = '<button type="button" class="close" aria-label="Close" id="hideTerm" onclick="hideTerm()"><span aria-hidden="true">&times;</span></button>'
    //日付ごとに処理
    /*
     * _WorkingTreeの構造は、8月上半期なら
     * 
     * {
     *   - "modified" : "2017/7/30"
     *   - "2017/8/1" : [勤務時間Obj1, 勤務時間Obj2...]
     *   - "2017/8/3" : [勤務時間Obj1, 勤務時間Obj2...]
     *   ...
     * }
     */
    for (var keyDay in _WorkingTree){
        if (_WorkingTree.hasOwnProperty(keyDay)){
            if (keyDay === "modified"){
                modifiedDay = _WorkingTree[keyDay];
            } else {
                shifts = _WorkingTree[keyDay];
                var alldaybonded = 0;
                var alldayrest = 0;
                for (shift of shifts){
                    var bonded = getBondedMinute(shift);
                    alldaybonded += bonded;
                    alldayrest += getRestMin(bonded);
                }
                html += '<div class="block"><p><strong>{0}</strong></p><p>勤務時間: {1}</p><p>実働時間: {2}h</p></div>'
                            .format(makeDateString(keyDay, '{0}/{1}/{2} ({3})'), makeWorktimeString(shifts), (alldaybonded-alldayrest)/60);
            }
        }
    }
    $("#showTerm").innerHTML += html;
    $("#termBack").style.display = 'block';
    showingTerm = true;
}

function hideTerm(){
    $("#showTerm").innerHTML = '';
    $("#termBack").style.display = 'none';
    showingTerm = false;
}

/*
 * min以上max未満であればtrue
 */
function isin(num, min, max){
    return num >= min && num < max;
}

/*
 * 拘束時間から休憩時間を求める関数。
 * 4.5 -  6 -> 0.5
 *   6 -  7 -> 0.75
 *   7 - 12 -> 1
 *  12 -    -> 2
 */
function getRestMin(bondedMin) {
    var restMin = 0;
    if (isin(bondedMin, 270, 360)){ //4.5h - 6h
        restMin = 30;
    } else if (isin(bondedMin, 360, 420)){ //6h - 7h
        restMin = 45;
    } else if (isin(bondedMin, 420, 720)){ //7h - 12h
        restMin = 60;
    } else if (bondedMin >= 720){ //12h -
        restMin = 120;
    }
    return restMin;
}

/*
 * worktimeObjの構造は、8:30-16:45なら
 *
 * {
 *  - "start"  - "hour" : 8
 *             - "min"  : 30
 *  - "finish" - "hour" : 16
 *             - "min"  : 45
 * }
 *
 * これから拘束時間を求める関数。
 */
function getBondedMinute(worktimeObj){
    var _st = worktimeObj["start"];
    var _fn = worktimeObj["finish"];

    var startH = _st["hour"];
    var startM = _st["min"];
    var finishH = _fn["hour"];
    var finishM = _fn["min"];

    if (finishH < startH || (finishH == startH && finishM < startM)){
        finishH += 24;
    }

    return (finishH - startH) * 60 + (finishM - startM);
}
/*
 * Day(月&日)に西暦(例えば2017)をつけ加えたYYYY/MM/DDみたいにする関数。
 * MM/DDなら2016/4/1と2017/4/1が区別できなくて、上書きされてしまうので。
 */
function addYearToDay(theDay) {
    var _day = theDay.split('/');
    var _theMonth = parseInt(_day[0]);
    var theDate = parseInt(_day[1]);

    // 年明け前に正月のシフト考えるような年明けを挟むときの処理
    year = today.getFullYear();
    if (today.getMonth() >= 10 && _theMonth <= 2){
        year ++;
    }

    return year + "/" + theDay;
}

/*
 * jQueryの$()とおんなじ
 * CSS-likeに#idとか.class、tagnameで、　HTML-DOM-Element or Array<HTML-DOM-Element>を返す関数。
 */
function $(elemId) {
    if (elemId.startsWith('#')){
        return document.getElementById(elemId.split('#')[1]);
    } else if (elemId.startsWith('.')){
        return document.getElementsByClassName(elemId.split('.')[1]);
    } else {
        return document.getElementsByTagName(elemId);
    }
}

String.prototype.format = function (arg) {
    var text = this;
    for (var i=0; i < arguments.length; i++) {
        text = text.replace("{" + i + "}", arguments[i]);
    }
    return text;
}

// bodyのロード時に関数を実行。 document.body === $('body')[0]。 ===は型まで同じでtrue。
document.body.onload = bodyLoadEvent();
</script>
</html>